#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
The first function "follow_on_rate（）" is to generate a list of the number of deals and the investors' follow-on rate.
And the second function "conn_adj_matrix()" is to generate an adjacency matrix where a connection between two investors
(by virtue of having participated in the same deal is denoted as one connection).
'''


def main():
    follow_on_rate()

    conn_adj_matrix()


def follow_on_rate():  # this function is to calculate the # of deals and the follow-on rate
    dict1 = {}
    dict2 = {}
    with open("fake_input.csv", 'r') as fin:
        next(fin)
        for line in fin:
            try:
                i1 = line.find(",")
                hasFollow, investors = line[:i1], line[i1 + 1:]
                if investors.strip() is '-':
                    continue
                else:
                    investors = investors.strip().strip("\"\';")
            except:
                continue
            for obj in investors.split(";"):
                obj = obj.strip()
                if obj is '':
                    continue
                elif obj in dict1:  # count deals
                    dict1[obj] += 1
                else:
                    dict1[obj] = 1
            if hasFollow is "1":  # count follow-ons
                if obj in dict2:
                    dict2[obj] += 1
                else:
                    dict2[obj] = 1
    with open("case_study_optput_1.csv", 'w') as fout:
        fout.write("Investor,# of Deals,# of Follow-Ons,Follow-On Rate\n")
        for obj in dict1:
            deals = dict1[obj]
            percent = 0
            if obj in dict2:
                percent = dict2[obj]
            fout.write('''"{0}",{1},{2},{3:.2f}%\n'''.format(
                obj, deals, percent, percent / deals * 100))


def conn_adj_matrix():  # this function is to create N by N connection matrix
    dicInvestorIndex = {}
    lstIndex2Investor = []
    matrix = []
    nextIndex = 0
    with open("fake_input2.csv", 'r') as fin:
        next(fin)
        for line in fin:
            try:
                investors = line[line.find(",") + 1:]
                if investors.strip() is '-':
                    continue
                else:
                    investors = investors.strip().strip("\"\';").split(";")
            except:
                continue
            indices = []
            for obj in investors:
                if obj is "":
                    continue
                elif obj in dicInvestorIndex:
                    indices.append(dicInvestorIndex[obj])
                else:
                    dicInvestorIndex[obj] = nextIndex  # assign each investor an unique value
                    indices.append(nextIndex)  # all investors in the same deal
                    while nextIndex > 0:
                        matrix.append([0] * nextIndex)
                    nextIndex += 1
                    lstIndex2Investor.append(obj)  # a list of connected investors
            n = len(indices)
            # here below is to count connections
            for i in range(n):
                for j in range(i + 1, n):
                    if (indices[j] != indices[i]):  # compare two unique values of investors
                        max_indices = max(indices[i], indices[j])
                        min_indices = min(indices[i], indices[j])
                        matrix[max_indices - 1][min_indices] += 1

    with open("case_study_optput_2.csv", 'w') as fout:
        n = len(lstIndex2Investor)
        fout.write("," + ",".join(lstIndex2Investor) + "\n")
        for i in range(n):
            fout.write(lstIndex2Investor[i])
            for j in range(n):  # write to adjacent matrix
                if i != j:
                    max_indices = max(i, j)  # compare between i and j
                    min_indices = min(i, j)
                    fout.write(",{0}".format(
                        matrix[max_indices - 1][min_indices]))  # eg: if i>j, use ".format(matrix[i - 1][j])"
                else:
                    fout.write(",-")
            fout.write('\n')



import pandas as pd
from pandas import Series, DataFrame
import numpy as np
import csv
import re
from itertools import product


def seed_date(df, n=1, column='deal_date'):  # This function is to select the earliest (seed) date
    return df.sort_values(by=column)[0:n]


def comb_invst(k_col, v_col):  # This function is to combine investors who participated in that deal
    lst = zip(k_col, v_col)
    sub = re.compile(r"(', ')")
    dic1 = {}
    dic2 = {}
    content = {}
    for k, v in lst:  # Assign multiple values to the same key
        dic1.setdefault(k, []).append(v)
        assert type(dic1.values()) == list, 'The type of dic1 values should be list'
    df = pd.DataFrame({"0": dic1.keys(), "1": dic1.values()})
    for i in range(len(df)):  # Use "re" to change the format of "item"(investors)
        item = str(df.iloc[i, 1])
        info = re.sub(sub, ';', item).strip().strip("\[\'\]\'")
        content[str(df.iloc[i, 0])] = str(info)
    dic2.update(content)
    combine = pd.DataFrame({"0": dic2.keys(), "1": dic2.values()})
    return (dic1, combine)


## Case_Study_1_(1)
deals = pd.read_csv('deals.csv', sep='|')
relation = pd.read_csv('deal_investor_relation.csv', sep='|')
investor = pd.read_csv('investor_general.csv', sep='|')

dfMerge1 = pd.merge(deals, relation, on='deal_id')
dfMerge2 = pd.merge(dfMerge1, investor, on='investor_id')
dfData = dfMerge2[dfMerge2['company_id'].notnull()]  # Get all rows with "company_id" not NaN

dfOutput = dfData.groupby([dfData['company_id'],  # Group by company_id & investor_id
                           dfData['investor_id']],
                          group_keys=False).apply(seed_date)

dfUnqDate = dfOutput[['company_id', 'deal_date']].groupby([dfOutput['company_id']], group_keys=False).apply(
    seed_date)  # Drop duplicated deal_date by company_id

(dict1, dfComb1) = comb_invst(dfOutput['company_id'], dfOutput['investor_id'])
(dict2, dfComb2) = comb_invst(dfOutput['company_id'], dfOutput['investor_name'])
dfComb = pd.merge(dfComb1, dfComb2, on="0")
dfComb.columns = ['company_id', 'investor_id', 'investor_name']

dfFinal = pd.merge(dfUnqDate, dfComb, on='company_id')
dfFinal.columns = ['Company ID', 'Seed Date', 'Seed Investor IDs', 'Seed Investors']
dfFinal.to_csv('case_study_output_1(1).csv', index=False)

## Case_Study_1_(2)
cont = []
for i in range(len(dict2.values())):
    x = dict2.values()[i]
    if len(x) > 1:  # The # of Investor in that deal is more than 1
        t = list(product(x, x))  # Get each pair of investors invested to the same company
        for elmt in t:
            assert len(elmt) == 2, 'The connection should be a pair'
            cont.append(elmt)
    else:
        continue

dfPair = pd.DataFrame(cont)
dfAdjMatrix = pd.crosstab(dfPair[0], dfPair[1])

for i in range(len(dfAdjMatrix)):  # Substitute the diagonal of adj_matrix into "-"
    dfAdjMatrix.iloc[i, i] = "-"

dfAdjMatrix.to_csv('case_study_output_1(2).csv')
